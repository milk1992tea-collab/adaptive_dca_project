# execution_engine.py
import time
from datetime import datetime
import csv
import ccxt

class ExecutionEngine:
    def __init__(self, exchange=None, mode="simulate", base_capital=10000, stop_loss=0.05, take_profit=0.1):
        """
        exchange: ccxt äº¤æ˜“æ‰€ç‰©ä»¶ (å¦‚ ccxt.bybit() æˆ– ccxt.binance())
        mode: "simulate" æ¨¡æ“¬æ¨¡å¼ / "live" å¯¦ç›¤æ¨¡å¼
        base_capital: åˆå§‹è³‡é‡‘ (USDT)
        stop_loss: æ­¢æç™¾åˆ†æ¯” (0.05 = 5%)
        take_profit: æ­¢ç›ˆç™¾åˆ†æ¯” (0.1 = 10%)
        """
        self.exchange = exchange
        self.mode = mode
        self.base_capital = base_capital
        self.stop_loss = stop_loss
        self.take_profit = take_profit
        self.positions = {}  # symbol -> {"qty": float, "entry_price": float}
        self.trade_log = []

        # è¼‰å…¥äº¤æ˜“æ‰€å¸‚å ´è³‡è¨Š (å¯¦ç›¤æ¨¡å¼éœ€è¦)
        if self.exchange:
            self.markets = self.exchange.load_markets()
        else:
            self.markets = {}

    def _adjust_order_size(self, symbol, qty, price):
        """èª¿æ•´æ•¸é‡ç¬¦åˆäº¤æ˜“æ‰€è¦æ ¼"""
        if symbol not in self.markets:
            return qty
        market = self.markets[symbol]
        min_qty = market.get("limits", {}).get("amount", {}).get("min", 0)
        step_size = market.get("precision", {}).get("amount", None)

        if min_qty and qty < min_qty:
            qty = min_qty
        if step_size:
            qty = round(qty, step_size)
        return qty

    def execute_signal(self, symbol, side, price, capital_fraction=0.1):
        """
        åŸ·è¡Œäº¤æ˜“è¨Šè™Ÿ
        side: "buy" æˆ– "sell"
        price: ç•¶å‰åƒ¹æ ¼
        capital_fraction: å–®ç­†äº¤æ˜“ä½”ç”¨è³‡é‡‘æ¯”ä¾‹
        """
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        trade_size = self.base_capital * capital_fraction / price
        trade_size = self._adjust_order_size(symbol, trade_size, price)

        if self.mode == "simulate":
            if side == "buy":
                self.positions[symbol] = {"qty": trade_size, "entry_price": price}
                self.trade_log.append((timestamp, symbol, side, price, trade_size, "SIM"))
                print(f"ğŸŸ¢ æ¨¡æ“¬è²·å…¥ {symbol} @ {price}, æ•¸é‡={trade_size}")
            elif side == "sell" and symbol in self.positions:
                entry = self.positions.pop(symbol)
                pnl = (price - entry["entry_price"]) * entry["qty"]
                self.trade_log.append((timestamp, symbol, side, price, entry["qty"], round(pnl,2)))
                print(f"ğŸ”´ æ¨¡æ“¬è³£å‡º {symbol} @ {price}, PnL={round(pnl,2)}")

        else:  # live æ¨¡å¼
            if not self.exchange:
                raise ValueError("âŒ exchange å°šæœªåˆå§‹åŒ–")
            order = self.exchange.create_order(symbol, "market", side, trade_size)
            self.trade_log.append((timestamp, symbol, side, price, trade_size, "LIVE"))
            print(f"âœ… å·²é€å‡ºå¯¦ç›¤è¨‚å–®: {order}")

    def risk_check(self, symbol, current_price):
        """æª¢æŸ¥æ­¢æ / æ­¢ç›ˆæ¢ä»¶"""
        if symbol not in self.positions:
            return
        entry = self.positions[symbol]
        change = (current_price - entry["entry_price"]) / entry["entry_price"]

        if change <= -self.stop_loss:
            print(f"âš ï¸ {symbol} è§¸ç™¼æ­¢æ {self.stop_loss*100}%")
            self.execute_signal(symbol, "sell", current_price)
        elif change >= self.take_profit:
            print(f"âœ… {symbol} è§¸ç™¼æ­¢ç›ˆ {self.take_profit*100}%")
            self.execute_signal(symbol, "sell", current_price)

    def close_all_positions(self, current_prices):
        """å¹³æ‰æ‰€æœ‰æŒå€‰"""
        for symbol, pos in list(self.positions.items()):
            price = current_prices.get(symbol, pos["entry_price"])
            self.execute_signal(symbol, "sell", price)

    def export_trades(self, filename="trade_log.csv"):
        """åŒ¯å‡ºäº¤æ˜“ç´€éŒ„"""
        with open(filename, "w", newline="", encoding="utf-8-sig") as f:
            writer = csv.writer(f)
            writer.writerow(["timestamp", "symbol", "side", "price", "qty", "extra"])
            writer.writerows(self.trade_log)
        print(f"ğŸ“ äº¤æ˜“ç´€éŒ„å·²å­˜æª”: {filename}")