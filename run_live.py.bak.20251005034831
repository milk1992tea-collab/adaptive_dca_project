# service daemon wrapper for run_live.py
import os
import sys
import time
import signal
import logging
import traceback
import subprocess
from datetime import datetime

# single-instance support
try:
    import psutil
except Exception:
    psutil = None

from signals_wrapper import main as _entry_main  # 若啟動函式非 main，請改名稱

# logging
LOG_DIR = os.path.join(os.path.dirname(__file__), "logs")
os.makedirs(LOG_DIR, exist_ok=True)
STDOUT_LOG = os.path.join(LOG_DIR, "stdout.log")
STDERR_LOG = os.path.join(LOG_DIR, "stderr.log")

# configure logging to file and console
logger = logging.getLogger()
logger.setLevel(logging.INFO)
formatter = logging.Formatter("%(asctime)s %(levelname)s %(name)s %(message)s")

# file handler (info and above)
fh = logging.FileHandler(STDOUT_LOG, encoding="utf-8")
fh.setLevel(logging.INFO)
fh.setFormatter(formatter)
logger.addHandler(fh)

# error file handler
eh = logging.FileHandler(STDERR_LOG, encoding="utf-8")
eh.setLevel(logging.ERROR)
eh.setFormatter(formatter)
logger.addHandler(eh)

# console handler (optional)
ch = logging.StreamHandler(sys.stdout)
ch.setLevel(logging.INFO)
ch.setFormatter(formatter)
logger.addHandler(ch)

def sanitize_for_log(s):
    try:
        if s is None:
            return ''
        value = str(s)
        for pat in ('\r', '\n', '`n', '\\`n'):
            value = value.replace(pat, '')
        return value
    except Exception:
        return str(s)

def safe_git(cmd_args):
    try:
        out = subprocess.check_output(cmd_args, stderr=subprocess.STDOUT, shell=False)
        return out.decode("utf8", errors="ignore").strip()
    except Exception:
        return ""

# PID lock
PIDFILE = os.path.join(os.path.dirname(__file__), "run_live.pid")

def already_running():
    if not os.path.exists(PIDFILE):
        return False
    try:
        with open(PIDFILE, "r") as f:
            pid = int(f.read().strip())
        if pid <= 0:
            return False
        # check process existence
        if psutil:
            return psutil.pid_exists(pid)
        else:
            try:
                os.kill(pid, 0)
                return True
            except Exception:
                return False
    except Exception:
        return False

def write_pidfile():
    try:
        with open(PIDFILE, "w") as f:
            f.write(str(os.getpid()))
    except Exception:
        logger.exception("Failed to write pidfile")

def remove_pidfile():
    try:
        if os.path.exists(PIDFILE):
            os.remove(PIDFILE)
    except Exception:
        pass

# graceful shutdown support
_shutdown = False

def _signal_handler(signum, frame):
    global _shutdown
    logger.info("Received signal %s, initiating shutdown", signum)
    _shutdown = True

signal.signal(signal.SIGTERM, _signal_handler)
try:
    signal.signal(signal.SIGINT, _signal_handler)
except Exception:
    # some Windows environments may not allow setting SIGINT here
    pass

def _service_main_loop():
    while not _shutdown:
        try:
            _entry_main()  # 若名稱不同請改成實際啟動函式
        except Exception as exc:
            logger.exception("Unhandled exception in service main loop: %s", exc)
            logger.error(traceback.format_exc())
            # sleep longer on exception to avoid fast crash loops
            for _ in range(10):
                if _shutdown:
                    break
                time.sleep(1)
        # small pause between iterations unless shutdown requested
        for _ in range(1):
            if _shutdown:
                break
            time.sleep(1)

def _graceful_run():
    try:
        if already_running():
            logger.info("Another instance is running, exiting")
            return
        write_pidfile()
        _service_main_loop()
    except KeyboardInterrupt:
        logger.info("Service interrupted by KeyboardInterrupt, exiting gracefully")
    except SystemExit:
        logger.info("Service received SystemExit, exiting gracefully")
    except Exception:
        logger.exception("Unexpected exception in graceful runner")
    finally:
        logger.info("Service stopped")
        remove_pidfile()

if __name__ == "__main__":
    _graceful_run()

